# 🤔 리액트에서 배열을 렌더링할 때 key를 써야 하는 이유는 무엇인가요?

> key는 리액트가 변경된 항목을 정확히 찾아내어 불필요한 렌더링을 줄이기 위해 사용된다.

<br />
<br />

## React의 재조정 (Reconcilication)

리액트는 선언적 API를 제공하기 때문에 갱신될 때마다 무엇이 바뀌었는지 걱정하지 않는다. React 내부에서는 `비교(diffing) 알고리즘`으로 컴포넌트의 갱신을 예측하면서 고성능 앱이라고 불릴 만큼 빠른 앱을 만들었다.

리액트는 `state`나 `prop`이 갱신되면 `render()` 함수로 새로운 React 앨리먼트 트리를 만든다. 이때 방금 만들어진 트리에 맞게 가장 효과적으로 UI를 갱신하는 방법을 알아야 한다.

하나의 트리를 다른 트리로 만들기 위한 최소한의 연산 수는 다양한 알고리즘 문제를 풀기 위한 일반적인 해결책들이 있지만, n개의 앨리먼트가 있는 트리에 대해 O(n\*\*3)의 복잡도를 갖고 있다. 리액트에서 이런 알고리즘을 그대로 사용하기엔 너무나 비싼 연산이다. 따라서 React는 두 가지 가정을 기반으로 O(n) 복잡도의 휴리스틱 알고리즘을 구현했다.

1. 서로 다른 타입의 두 엘리먼트는 서로 다른 트리를 만들어낸다.
2. 개발자가 key prop을 통해, 여러 렌더링 사이에서 어떤 자식 엘리먼트가 변경되지 않아야 할지 표시해 줄 수 있다.

<br />
<br />

## Diffing Algorithm

리액트가 두 개의 트리를 비교할 때는 두 엘리먼트의 루트 엘리먼트부터 비교한다. 이후 동작은 루트 엘리먼트의 타입에 따라 달라진다.

### 1. 엘리먼트의 타입이 다른 경우

두 루트 엘리먼트의 타입이 다른 경우에는 이전 트리를 버리고 완전히 새로운 트리를 만든다.

트리를 버릴 때 이전 DOM 노드는 모두 파괴된다. 컴포넌트 인스턴스는 `componentWillUnmount()`가 실행된다. 새로운 트리가 만들어질 때, 새로운 DOM 노드들이 DOM에 삽입되고, 그에 따라 컴포넌트 인스턴스는 `UNSAFE_componentWillMount()`가 실행되고 `componentDidMount()`가 이어서 실행된다. 그리고 이전 트리와 연관된 모든 state는 사라진다.

```jsx
<div>
  <Counter />
</div>
```

```jsx
<span>
  <Counter />
</span>
```

<br />

### 2. DOM 엘리먼트의 타입이 같은 경우

같은 타입의 두 리액트 DOM 엘리먼트를 비교할 때, 리액트는 두 엘리먼트의 속성을 확인하고 동일한 내역은 유지한채 변경된 속성들만 갱신한다.

```jsx
<div className="before" title="stuff" />
```

```jsx
<div className="after" title="stuff" />
```

위와 같은 경우에는 현재 DOM 노드 상에 className만 수정한다.

<br />

### 3. 같은 타입의 컴포넌트 엘리먼트

컴포넌트가 갱신되면 인스턴스는 동일하게 유지되어 렌더링 간 state가 유지된다. 리액트는 새로운 엘리먼트의 내용을 반영하기 위해 현재 컴포넌트 인스턴스의 prop을 갱신한다. 이때 해당 인스턴스의 `UNSAFE_componentWillReceiveProps()`, `UNSAFE_componentWillUpdate()`, `componentDidUpate`를 호출한다. 그리고 `render()` 메서드가 호출되고 비교 알고리즘이 이전 결과와 새로운 결과를 재귀적으로 처리한다.

<br />

**자식에 대한 재귀적 처리**

DOM 노드의 자식들을 재귀적으로 처리할 때, 리액트는 기본적으로 동시에 두 리스트를 순회하고 차이점이 있으면 변경을 생성한다. 만약 자식의 끝에 엘리먼트를 추가하면, 두 트리 사이의 변경을 잘 작동한다.

```jsx
<ul>
  <li>first</li>
  <li>second</li>
</ul>
```

```jsx
<ul>
  <li>first</li>
  <li>second</li>
  <li>third</li>
</ul>
```

예를 들어, 위 코드의 경우 `<li>third</li>`가 마지막 자식 노드로 추가되었기 때문에 단순하게 마지막 노드만 추가하면 된다.

```jsx
<ul>
  <li>first</li>
  <li>second</li>
  <li>third</li>
</ul>
```

```jsx
<ul>
  <li>second</li>
  <li>third</li>
</ul>
```

하지만 이런 경우, 첫 번째 노드인 `<li>first</li>`를 추가하면 그 아래 second, third 노드들도 변경해야 하므로 비효율적이라는 문제가 발생한다.

<br />

**Keys**

이때 리액트는 key 속성으로 문제를 해결했다. 자식 노드들이 key를 가지고 있다면, 리액트는 key를 통해 기존 트리와 이후 트리의 자식들이 일치하는지 확인한다.

```jsx
<ul>
  <li key="1">first</li>
  <li key="2">second</li>
  <li key="3">third</li>
</ul>
```

```jsx
<ul>
  <li key="2">second</li>
  <li key="3">third</li>
</ul>
```

방금 본 코드에 key를 추가했다. 이 코드는 이제 second, third 노드를 변경하는 것이 아니라 위치만 이동하면 되므로 성능이 개선되었다.

<br />

**좋은 key 값**

렌더링하려는 엘리먼트는 일반적으로 `식별자(ex. id)`를 가지고 있을 것이고, 그대로 사용하면 된다. 하지만 노드를 유일하게 구분할 수 있는 식별자가 없는 경우라면 임의적으로 id를 추가하거나, 데이터 일부에 해시를 적용해 key를 생성할 수 있다.

노드를 유일하게 구분할 수 있는 값이면 충분히 좋은 값이지만, key는 형제 사이에서만 유일하면 되고, 전역에서 유일할 필요는 없다.

최후의 수단으로 배열의 인덱스를 key로 사용할 수 있지만, 추천하지 않는다. 왜냐하면 배열이 수정되는 경우가 생기면 예상하지 못한 문제가 발생할 수 있기 때문이다. 앞서 알아 봤듯이 컴포넌트 인스턴스는 key를 기반으로 갱신되고 재사용되므로, 항목의 순서가 바뀌면 key 값도 함께 바뀌게 된다. 그래서 컴포넌트의 state가 의도치 않은 방식으로 바뀔 수 있는 것이다.

<br />
<br />

## 결론

리액트는 휴리스틱에 의존하고 있기 때문에, 휴리스틱을 지키지 않는 경우 성능이 나빠진다. 그러므로 우리는 아래 두 가지 원칙을 잘 이해하고 실제 코드에 적용시키는 노력이 필요하다.

1. 알고리즘은 다른 컴포넌트 타입을 갖는 종속 트리들의 일치 여부를 확인하지 않습니다. 매우 비슷한 결과물을 출력하는 두 컴포넌트를 교체하고 있다면, 그 둘을 같은 타입으로 만드는 것이 더 나을 수도 있다.
2. key는 반드시 변하지 않고, 예상 가능하며 유일해야 한다. 변하는 key(Math.random()으로 생성된 값 등)을 사용하면 많은 컴포넌트 인스턴스와 DOM 노드를 불필요하게 재생성하여 성능이 나빠지거나 자식 컴포넌트의 state가 유실될 수 있다.

<br/>
<br/>

---

https://ko.legacy.reactjs.org/docs/reconciliation.html#recursing-on-children

# 🤔 브라우저는 어떻게 동작하나요?

<br>
<br>

```
💡 먼저 보면 좋을, 브라우저 동작 과정의 핵심 과정

1. DOM 트리 구축
2. CSSOM 구축
3. 스타일
4. 레이아웃
5. 페인트
```

<br>
<br>

## 좋은 사용자 경험

사용자에게 좋은 웹 경험이라면 당연히 ‘빠른’ 사이트로, 상호작용이 원할한 사이트를 꼽는다.

<br>
<br>

## 1️⃣ 탐색(Navigation)

웹 페이지를 로딩하는 첫 단계로, 사용자가 주소창에 URL을 입력하거나, 링크 클릭 등 동작을 통해 요청을 보낼 때마다 발생한다. 따라서 웹 최적화의 목표 중 하나는 탐색이 완료될 때까지의 시간을 최소화하는 것이다.

<br>

### DNS 조회

IP 주소가 `93.184.216.34`인 사용자가 `https://example.com`을 주소창에 입력했다. 처음 방문하는 사이트라면 DNS 조회가 필요하다.

DNS 조회는 최종적으로 DNS 서버에 의해 처리되고, IP 주소로 응답한다. 최초의 요청 이후에는 IP 주소가 일정 기간 캐시 되어 후속 요청 속도를 높인다.

DNS 조회는 일반적으로 호스트 이름 하나당 한 번만 수행하지만, 요청된 페이지에서 참조하는 다른 호스트 이름이 있다면 조회를 각각 수행한다.

<br>

### TCP 핸드셰이크

이렇게 DNS 조회를 통해 IP 주소를 알았다면, 브라우저와 서버는 TCP 3방향 핸드셰이크로 연결을 설정한다. TCP 3방향 핸드셰이크는 `“SYN-SYN-ACK”`로, 두 컴퓨터 간 TCP 세션을 협상하고 시작하기 위해 본 요청이 보내지기 전 3개의 추가적인 메시지를 주고 받는 것이다.

**HTTPS**

HTTPS는 HTTP보다 보안성을 강화한 개념으로, 웹에서 데이터를 안전하게 주고받기 위한 보안 프로토콜이다. 데이터를 암호화하여 송수신 하면서 데이터가 중간에 도청되거나 변조되는 것을 방지한다. 따라서 HTTPS를 이용하려면 또 다른 핸드셰이크로, 실제 요청 전에 클라이언트에서 서버로 3번 더 왕복한다.

물론, 지연시간이 조금 더 길어지기는 하지만 안전한 연결을 위해선 충분히 기다릴 가치가 있는 과정이다.

<br>
<br>

## 2️⃣ 응답(Response)

웹 서버로 한 번 연결이 되고 나면, 브라우저는 유저 대신 초기 `HTTP get request`를 보낸다. 대게 HTML 파일을 요청하고, 서버는 요청을 받으면 관련 응답 헤더와 함께 HTML 내용을 응답한다.

<br>
<br>

## 3️⃣ 구문 분석(Parsing)

브라우저가 첫 번째 데이터를 받으면, 수신된 정보를 구문 분석한다.

구문 분석이란, 브라우저가 네트워크를 통해 받은 데이터를 DOM이나 CSSOM으로 바꾸는 단계이다. 렌더러가 화면에 페이지를 그릴때 사용하게 된다.

브라우저는 마크업을 내부적으로 DOM으로 표현하고, DOM은 Javascript의 다양한 API를 통해 조작된다.

<br>

### DOM 트리 구축

쉽게 말해, HTML을 처리해 DOM 트리 생성하는 과정이다.

DOM 트리는 문서의 내용을 설명한다. 트리는 다른 HTML 태그간의 관계와 계층을 반영한다. DOM 노드의 개수가 많아질 수록, DOM 트리 구축에 오랜 시간이 소요된다.

<br>

### 프리로드 스캐너 (Preload scanner)

DOM 트리 구축이 메인 쓰레드에서 진행되기 때문에, 프리로드 스캐너는 사용 가능한 콘텐츠를 분석하고, CSS나 Javascript, 웹 폰트와 같이 우선순위가 높은 자원을 요청한다. (필요한 자원을 미리 요청한다.)

<br>

### CSSOM 구축

CSS 객체 모델은 DOM과 비슷하게 트리 구조이다. 브라우저는 CSS 규칙을 이해할 수 있고 작업을 진행할 수 있도록 스타일 맵으로 변환한다. 그리고 CSS에 있는 규칙으로 트리 노드를 만들고, CSS 선택기에 기반해서 부모 노드, 자식 노드, 형제 관계의 노드를 만든다.

이때 CSSOM 트리는 사용자 에이전트의 스타일 시트도 포함한다. 브라우저는 노드에 적용 가능한 가장 일반적인 규칙부터 적용하고, 재귀적으로 더 구체적으로 적용된 규칙을 계산해서 스타일을 수정한다.

CSSOM의 과정이 복잡해보이지만, 실제로 소요되는 시간은 DNS 조회보다 짧기 때문에 웹 성능 최적화의 관점에서 큰 영향을 주진 않는다.

<br>

### 다른 작업들 : Javascript 컴파일 / 접근성 트리 구축

1. **Javascript 컴파일**
   - CSSOM이 생성되는 동안, 프리 스캐너를 통해 Javascript 파일 같은 다른 자원도 다운로드 된다. Javascript는 해석, 컴파일, 구문 분석 및 실행한다.
   - Javasciprt 컴파일 과정으로는, 스크립트가 추상 구문 트리로 분석되고, 브라우저 엔진이 추상 구문 트리를 인터프리터에게 넘기면서 메인 쓰레드에서 실행되는 바이트코드가 생성된다.
2. **접근성 트리 구축**
   - 브라우저는 접근성 트리를 만들고, 보조 장치는 이 트리를 이용해 내용을 분석하고 해석한다.
   - 접근성 객체 모델(AOM)은 DOM의 의미 버전으로, 브라우저가 DOM을 업데이트할 때 접근성 트리도 함께 업데이트 한다. 접근성 트리가 자체적으로 수정될 수는 없다.

<br>
<br>

## 4️⃣ 렌더(Render)

렌더링 과정에는 스타일, 레이아웃, 페인트, 합성 등이 포함된다. CSSOM과 DOM 트리는 구문 분석되는 과정에서 생성되고 렌더 트리로 합성된다. 렌더 트리가 요소의 레이아웃을 계산하고 나면, 그때서야 화면에 페인트 된다. (화면에 그려진다.)

<br>

### 스타일

DOM과 CSSOM을 합쳐 렌더 트리를 만든다. 계산된 스타일 트리는 DOM 트리의 루트부터 시작해서 눈에 보이는 노드를 순회하며 만들어진다.

만약 `display` 속성이 `none`인 경우처럼, 화면에 나타나지 않는 태그는 렌더링 결과에 나타나지 않을 것이니 처음부터 렌더 트리에 포함되지 않는다. 다만, `visibility: hidden` 속성은 요소가 자리를 차지하기 때문에 렌더 트리에 포함된다.

각각의 노드는 그 노드만의 CSSOM 규칙이 있고, 렌더 트리가 보이는 모든 노드의 내용과 계산된 스타일 정보를 갖고 있다. DOM 트리에서 보이는 모든 노드에 관련된 스타일을 맞춰보고, CSS cascade 방식에 따라 최종적으로 보여질 스타일을 결정한다.

<br>

### 레이아웃

렌더 트리를 기반으로 각 노드의 도형 값을 계산하기 위해 레이아웃을 실행한다. 레이아웃은 렌더 트리에 있는 모든 너비, 높이, 위치를 결정하는 프로세스이며, 페이지에서 각 객체의 크기와 위치도 계산한다. (한 마디로, 처음 노드의 사이즈와 위치가 결정되는 것이다.)

리플로우는 레이아웃 이후에 페이지 일부분, 전체 문서에 대한 크기, 위치에 대한 결정이다. (한 마디로, 레이아웃 이후 다시 노드의 크기와 위치를 계산하는 것이다.)

렌더 트리가 한 번 만들어지면 레이아웃 단계가 시작된다. 렌더 트리는 스타일 단계에서 계산된 스타일과 함께 어떤 노드가 화면에 보여질지 식별하지만, 각 노드의 위치나 좌표는 모른다. 이때 브라우저는 객체의 정확한 크기와 위치를 결정하기 위해 렌더 트리의 루트부터 시작해 순회한다.

<br>

### 페인트

페인팅 혹은 레지스터화 단계에서 브라우저는 레이아웃 단계에서 계산된 각 박스를 실제 화면의 픽셀로 변환한다. 페인팅에서 요소의 모든 시각적인 부분을 화면에 그리는 작업이 포함되며, 브라우저는 매우 빠르게 동작해야 한다.

페인팅은 레이아웃 트리의 요소를 레이어를 분리할 수 있다. 레이어는 성능을 향상시키지만 메모리 관리에서는 비싼 작업이다. 따라서 웹 성능 최적화 전략으로 과도하게 쓰이면 안된다.

<br>

### 합성

이렇게 문서의 각 섹션이 다른 레이어에서 그려질 때, 섹션을 겹쳐놓으면서 올바른 순서로 화면에 그려지는 것과 정확한 렌더링을 보장하기 위해 합성이 필요하다.

페이지가 계속해서 자원을 로드하면 리플로우가 일어날 수 있고, 리플로우는 리페인트와 재합성을 일으킬 수 있다. 이때 요소의 사이즈를 미리 정해놨다면 리플로우는 필요하지 않을 것이고, 잇따라 오는 불필요한 과정을 줄인다.

<br>
<br>

## 5️⃣ 상호작용(Interactivity)

메인 쓰레드가 페이지 그리는 것을 완료하는 것이 끝은 아니다. 지연된 Javascript, onload 이벤트 발생으로 코드가 동작한다면 메인 쓰레드는 또 다시 바쁠 것이다.

Time to Interactive(TTI)는 DNS 조회와 SSL 연결이 이뤄지는 첫 요청부터 페이지가 상호작용할 준비가 될 때까지 얼마나 걸리는지 측정하는 단위이다. 첫 번째 콘텐츠가 포함된 페인트 이후 페이지가 사용자와의 상호작용에 50ms 이내로 응답할 때를 상호작용 가능한 시점으로 본다.

<br>
<br>

## 결론

웹 페이지가 로드되는 과정은 `탐색 ⇒ 응답 ⇒ 구문 분석 ⇒ 렌더링 ⇒ 상호작용`의 순서대로 이어진다.

1. **탐색 (Navigation)**
   - 사용자가 URL을 입력하거나 링크를 클릭해 서버에 요청하는 과정이다.
   - DNS 조회와 TCP 핸드셰이크가 포함되고, HTTPS는 보안 강화를 위해 추가적인 핸드셰이크가 필요하다.
2. **응답 (Response)**
   - 서버가 요청을 처리하고 HTML 등 데이터를 클라이언트로 보내는 과정이다.
3. **구문 분석 (Parsing)**
   - 받은 데이터를 브라우저가 DOM, CSSOM 등으로 변환하는 과정이다.
   - DOM과 CSSOM을 합쳐 렌더 트리가 생성되고, 이 트리는 렌더링을 위한 계산에 사용된다.
4. **렌더 (Render)**
   - 페이지가 화면에 표시되는 단계로, 스타일 계산, 레이아웃, 페인트, 합성 등의 과정이 포함된다.
   - 이 단계에서 렌더 트리를 기반으로 실제 화면을 그린다.
5. **상호작용 (Interactivity)**
   - 페이지가 사용자의 입력을 받거나 이벤트를 처리하는 단계이다.
   - TTI를 측정해 페이지가 얼마나 빨리 사용자와 상호작용할 준비가 되었는지를 평가할 수 있다.

<br>
<br>

---

https://developer.mozilla.org/ko/docs/Web/Performance/Guides/How_browsers_work
